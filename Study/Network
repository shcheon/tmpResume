- **Web의 동작 방식**

  1. 사용자가 브라우저에 URL을 입력

  2. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음 (Domain Name System : 도메인 이름을 IP로 변경해주는 서버)

  3. HTTP로 Request 메세지를 생성함

  4. TCP/IP 연결을 통해 서버로 전송됨

  5. 웹 서버는 HTTP Request에 대한 Response 메세지를 생성함

  6. TCP/IP 연결을 통하여 요청한 컴퓨터로 전송

  7. 도착한 HTTP Response는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 봄

     

- **HTTP 특징**

  - Hyper Text Transfer Protocol의 약자로, 웹 상에서 사용되는 데이터 송수신 프로토콜

  - 비연결성(Conectionless)

    - 연결을 유지하기 위한 리소스를 사용하지 않음
    - 연결하기 위해 KeepAlive 속성 사용 가능 (HTTP 1.x 이후)

  - 평문으로 전송 

    - 보안에 취약하지만, 암호화와 복호화 과정이 없어 빠르게 데이터를 전송

  - 무상태 (Stateless)

    - 클라이언트가 어떠한 상황에서 요청값을 전송하였는지 알지 못함
    - 상태를 알기 위해, 쿠키,세션, 토큰기반 인증을 사용
      * 쿠키 : 사용자 브라우저에 저장되는 데이터
      * 세션 : 서버에 저장하는 데이터
      * 토큰 기반 인증 : 보호할 데이터를 토큰으로 치환하여 사용, 즉 토큰으로 데이터를 암호화한 것 (OAuth, JWT를 사용)

    

- **HTTP 통신방식**

  - 요청 / 응답 구조로 이루어져 있으며, 상태값을 저장하지 않음(Stateless)

  

- **HTTP 구조**

  - HTTP 메세지는 Method, Path, Version, Header, Body로 구성되어 있음

  

- **HTTP Request의 구조**

  - 시작라인  : 요청 Path, HTTP Method와 Version이 명시되어 있음

    - GET /search HTTP/1.1

  - Header : 요청에 대한 추가정보가 담겨있음, Key-Value로 데이터가 구성되어 있음 (Key:Value)

    - 대표적인 Header 
      - Host : 요청을 보낸 URL 
      - User-Agent : 클라이언트 정보, 웹 브라우저 정보
      - Accept : 해당 요청을 받을 수 있는 응답 타입 ex) application/json
      - Connection : 해당 요청이 끝난 후에 클라이언트와 서버간 커넥션 유지 여부를 나타냄 ex) Keep-alive
      - Content-Type : body의 타입
      - Content-Length : body의 길이

  - Body : 요청 내용

    - GET 요청은 주로 Body가 없음

      

- **HTTP Response의 구조**

  - 상태 라인 :  HTTP 버전, 상태 코드, 상태 메세지가 명시

    - HTTP/1.1 404 Not Found

  - Header : Request의 Header와 동일

  - Body : 응답 내용

    

- **HTTP 버전 별 특징**

  - HTTP 0.9 : HTML 문서만 전송하는 목적이였음. GET mehtod만 지원하였으며, MIME/Header/Version 정보를 전송 하지 않았음

  

  - HTTP 1.0 
    - 한 개의 커넥션 당 하나의 요청을 처리하고 다음 요청에 대한 응답을 순차적으로 처리하는  구조
    - 요청-응답 완료 후, 연결이 끊어지므로, Keep-Alive 헤더를 활용하여 재연결 지연을 감소
    - 상태코드 라인/Header/Version/MIME 전송 추가,  HTML이외에 다른 문서도 전송할 수 있도록 변경, GET/POST/PUT 추가

  

  - HTTP 1.1

    - HTTP 1.0의 성능을 개선하기 위해 탄생한 버전 (HTTP 1.1은 표준이며, 브라우저별로 기능을 지원하는지 확인 필요)

    - Host Header가 추가되어 , 여러 도메인을 지정하여 여러 개의  요청을 할 수 있음

    - GET/PUT/POST/UPDATE/DELETE/OPTION/TRACE method 추가

    - 영구 접속 (Persistent Connection)

      - HTTP 1.1에서는 기본적으로 활성화 되어 있는 기능 
      - 클라이언트-서버 간 요청-응답이 완료할 떄마다, 연결을 새로 하지 않고, 기존 연결을 유지하여 재사용하는 방법

    - Cache-Control 헤더 추가

      - cache 정책에 따라, 로컬 PC에 저장된 HTTP 응답을 브라우저에게 바로 보여줌으로써, 불필요한 통신을 줄임

    - Multiple Request 전송 기능 추가(파이프라이닝)

      - 클라이언트의 첫번째 요청에 대한 응답이 수신되기 전에 두번째 요청 전송 가능 ()

      

  - HTTP 1.1의 문제점

    - 첫번째 요청에 대한 응답이 수신되지 않으면 두번째 응답이 진행되지 않는 문제가 발생 (Head Of line Blocking)
    - 요청할 때마다, 헤더정보와 쿠키를 전송하므로, 통신 자원 낭비가 발생

    

  - HTTP 1.1 문제점 해결방안

    - 파이프라인 활용한 도메인 샤딩(Domain Sharding)

      - 리소스를 여러 개의 도메인으로 나누고, 이를 커넥션당 다른 도메인 요청을  병렬로 전송하여 네트워크 요청시간을 단축 
      - 도메인 당 커넥션의 개수가 정해져 있으므로, 근본적인 문제를 해결하는 솔루션은 아님

    - 이미지 스프라이트 (Image Sprite)를 이용하여 RTT 시간 단축

      - 여러 개의 이미지를 하나의 이미지로 합치는 방법
      - 합쳐진 이미지를 요청하여, 응답받은 이미지를 CSS의 좌표를 이용하여 이미지를 추출하여 사용

    - HTML 문서 내용 배치 순서 변경

      - 스타일 시트는 문서 상위에 배치, 스크립트는 HTML 문서 하단에 배치

      - HTML는 상위에서 하위로 로딩하므로, 중간에 Script를 로딩할 경우 Script로딩이 완료되기 전까지 다른 정적자원이 로딩되지 않아 사용자 입장에서는 UI가 멈춘 것으로 생각할 수 있으므로 UX에 좋지 않음

        

  - HTTP 2.0 

    - 현장에 많이 적용되어 있지 않음.
    - 멀티플랙싱 기능 추가 : 하나의 커넥션으로 여러개의 HTTP 요청/응답을 주고받을 수 있음
    - Huffman Encoding 으로 전송 헤더 데이터를 압축하여 네트워크 응답시간을 줄임
    - 서버 푸시 추가 : 클라이언트가 HTML문서 하나만 요청하여도, 서버가 HTML과 그 안에 포함되는 CSS, IMG 등을 알아서 보내주는 기능을 추가하여, 클라이언트 요청 시간을 최소화

    

  - HTTP 3.0

    - 개발 진행 중?

  

- **HTTPS** 

  - 

  

- **HTTP Method**

  - 클라이언트가 서버로 HTTP 요청을 전송할 떄 어떠한 목적의 행위인지 명시하는 방법 

  - GET : 서버에게 리소스를 요청할 때 사용

  - HEAD : GET과 동일하지만, HEAD만 요청할 때 사용

  - PUT : 서버가 가지고 있는 URI의 본문 내용변경을 요청할 때 사용

  - POST : 서버에 데이터를 전송하여 새로운 본문 입력 또는 데이터 생성 변경을 요청할 때 사용

  - DELETE : 서버에 URI 리소스를 삭제 요청할 때 사용

    ex ) GET /data/select/1 HTTP 1.1

    

- **HTTP Status Code**

  - 1XX - 메시지 정보, 2XX - 요청 성공, 3XX - 리다이렉션, 4XX - 클라이언트 오류, 5XX - 서버오류

    - 200 OK 
    - 301 Moved Permanetly
    - 400 Bad Request 
    - 401 Unauthorized 
    - 403 Forbidden 
    - 404 Not Found 
    - 500 Internal Server Error 

    

- **REST, REST API**

  - Representational State Transfer의 줄임말로, 아키텍처를 말함
  - REST 또는 Web 아키텍처
    - 클라이언트/서버 구조 -> 서버/클라이언트는 역할이 다르며, 독립적인 역할을 수행함.
    - 단일 인터페이스(Uniform Interface) -> 모든 플랫폼에서 사용 가능한 API를 제공해야 함
    - 무상태(Stateless) -> 클라이언트의 상태를 서버에 저장하지 말아야 함
    - 캐시처리가능(Cacheable) -> HTTP를 이용하므로, 캐시를 이용할 수 있어야 함. 
    - 계층화(Layered System) -> 클라이언트는 어느 서버와 연결되어 있는지 알 수 없
    - 자체 표현 구조(Self-descriptiveness) -> API만 보았을 때, 어떤 역할을 수행하는지 알 수 있어야 함
  - REST 안티 패턴
    - REST 사상에 어긋나는 행위를 하는 경우를 안티패턴이라고 봄
    - GET 또는 POST를 이용한 터널링
      - GET 또는 POST 요청 만으로 서버에 SELECT, DELTE, INSERT, UPDATE를 요청하는 패턴
    - HTTP Response Code를 사용하지 않는 경우

- **Cookie**
  - HTTP의 비연결성, 무상태 특성을 보완하기 위해 사용
  - 클라이언트에 저장되는 Key-Value 형태의 데이터 파일
  - 최대 300개 까지 저장가능하며, 유효 시간이 있고, 도메인당 20개 값만 가질 수 있으며, 4KB까지 저장가능
  - ResponseHeader에 Set-Cookie속성을 사용하면 쿠키 생성가능
  - 쿠키는 사용자가 별도로 설정하지 않아도, 브라우저가 Rquest 전송 시 Header에 넣어서 서버에 전송함
- **Cookie 동작방식**
  1. 클라이언트가 페이지 요청
  2. 서버에서 쿠키를 생성
  3. HTTP헤더에 쿠키를 포함시켜 응답
  4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
  5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
  6. 서버에서 쿠키를 읽어 이전상태 정보를 변경 할 필요가 있을 떄 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답



- **Session**

  - 쿠키를 기반으로 하고 있지만, 데이터 파일을 서버에 저장함
  - 클라이언트가 서버에 Request를 보내면 클라이언트에게 고유의 세션ID를 부여하며, 브라우저가 서버에 접속한 후 종료할 떄까지 상태를 유지함
  - 접속 제한 시간을 설정할 수 있으며, 일정 시간 응답이 없을 경우 세션이 해제되도록 설정 가능
  - 세션은 서버 리소스를 사용하므로, 서버 성능에 많은 영향을 미침

  

- **Session 동작방식**

  1. 클라이언트가 서버에 접속 시 세션 ID를 발급받음
  2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장\
  3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용
  4. 세션 ID를 전달 받은 서버는 세션 ID로 세션에 있는 클라이언트 정보를 가져옴
  5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답함



- **Cookie와 Session의 차이**
  - 쿠키는 클라이언트, 세션은  서버에 저장됨
  - 처리속도는 쿠키가 더 빠름, 세션은 서버에서 처리가 필요하므로 쿠키보다 느림
  - 쿠키는 클라이언트에 저장되어 변질되거나 전송 중 스니핑되어 변조될 수 있으므로 보안상 취약하지만, 세션은 서버에서 처리하므로 보안성이 좋음



- **토큰 기반 인증**

  - 클라이언트에게 토큰을 부여하여, 인증시 토큰 기반으로 사용자 인증을 수행하는 방법

  -  Token을 발행해서 클라이언트에 보내주므로, Session

  - JWT(JSON Web ToKen)을 이용함

    

- 토큰 기반 동작 방식
  1. 사용자가 로그인 함
  2. 서버에서 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 기타 정보와 함께 Payload에 집어 넣음
  3. JWT 토큰의 유효기간을 설정함
  4. 암호화 할 Secret Key를 이용해 Access Token을 발급
  5. 사용자는 Access Token을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 싣어 보냄
  6. 서버에서는 해당 토큰의 Verify Signature를 Secret key로 복호화 한 후, 조작여부, 유효 기간을 확인함
  7. 검증이 완료되었을 경우, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옴



- **OSI 7 Layers**

  - 네트워크에서 통신이 일어나는 과정을 7단계로 분류한 계층

  - 7 계층 (Application Layer) : 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층

  - 6 계층 (Presentation Layer) : 데이터의 형식을 정의하는 계층

  - 5 계층 (Session Layer) : 컴퓨터끼리 통신하기 위해 세션을 만드는 계층

  - 4계층 (Transport Layer) : 최종 수신 프로세서로 데이터의 전송을 담당하는 계층 (UDP, TCP 이용)

  - 3 계층 (Network Layer) : 패킷을 목적지까지 가장 빠른 길로 전송을 담당하는 계층 (IP주소로 전송)

  - 2 계층 (Datalink Layer) : 데이터의 물리적인 전송과 에러 검출, 흐름제어를 담당하는 계층 (MAC주소로 전송)

  - 1 계층 (Physical Layer) : 데이터를 전기신호로 바꾸어주는 계층

    

- **TCP/IP**

  - TCP 프로토콜과 IP 프로토콜을 합쳐서 부르는 용어

  - IP는 네트워크에서 패킷을 교환할 때,  목적지까지 빠르게 전송하기 위한 프로토콜이며, TCP는 목적지까지 데이터 손실 없이 무사히 도착하였는지, 순서가 올바른지, 네트워크의 혼잡도 고려하는 역할을 하는 프로토콜 임. TCP와 IP를 같이 자주 쓰이므로, TCP/IP로 묶어서 말함

    

- **TCP와 UDP의 차이점**

  - TCP는 가상회선을 만들어 목적지까지 전송할 논리적인 연결을 만들고, 각 패킷은 가상 식별 번호가 부여되어 패킷들이 순서대로 도착하고, 신뢰성이 높 . 통신은 1:1로만 가능하며 UDP에 비해 속도가 느리다는 단점이 있음

  - UDP는 패킷에 목적지 주소만 이용하여 전송되므로, 동일 패킷이라 하더라도 목적지까지 도착하는 네트워크 경로는 다를 수 있음.  통신은 1:1 1:N N:N이 가능하며, 연결과정이 없으므로, TCP보다 빠르지만 데이터 신뢰성을 보장하지 못한다는 단점이 있음

  - TCP의 혼잡제어, 흐름제어, 순서 제어 등이 가능한 이유는 헤더에 정보가 포함되어 있기 때문임. UDP 헤더는 목적지 주소이외에 없다고 봐도 무방.

    

- **TCP 의 3-ways handshake**

  - 세션 만들때 사용됨
  - Client -> Server : TCP SYN 전송
  - Client <- Server : TCP SYN ACK 전송
  - Client -> Server : TCP ACK 전송

  

- **TCP 의 4-ways handshake** 

  - 세션 종료할 때 사용됨

  - Client -> Server : FIN 전송

  - Client <- Server : ACK 전송

  - Client <- Server : FIN 전송

  - Client -> Server : ACK 전송

    

- 암호화, 복호화 방식에 대해 설명해보세요

- 

- 네트워크 보안에 대하여 설명해보세요
